// src/main/java/com/intelliTask/core/model/User.java

package com.intelliTask.core.model;

import jakarta.persistence.*; // JPA annotations
import java.time.LocalDateTime; // For timestamps
import lombok.Getter;           // Lombok annotation for getters
import lombok.Setter;           // Lombok annotation for setters
import lombok.NoArgsConstructor; // Lombok annotation for no-arg constructor
import lombok.EqualsAndHashCode; // Lombok annotation for equals and hashCode
import lombok.ToString;         // Lombok annotation for toString

import org.hibernate.annotations.CreationTimestamp; // Hibernate specific for timestamps
import org.hibernate.annotations.UpdateTimestamp;   // Hibernate specific for timestamps

/**
 * Represents a user in the intelliTask system.
 * This class is now a JPA Entity, meaning it will be mapped to a database table.
 * Getters, setters, equals, hashCode, and toString methods are generated by Lombok.
 *
 * UPDATED: Integrated Lombok annotations and adapted for JPA entity mapping.
 */
@Entity // Marks this class as a JPA entity, mapped to a database table
@Table(name = "users") // Specifies the table name in the database. Good practice to explicitly name tables.
@Getter // Lombok: Generates all boilerplate getter methods for fields
@Setter // Lombok: Generates all boilerplate setter methods for fields
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED) // Lombok: Generates a protected no-argument constructor, required by JPA
@EqualsAndHashCode(of = "id") // Lombok: Generates equals() and hashCode() based *only* on the 'id' field, crucial for JPA entities
@ToString // Lombok: Generates a comprehensive toString() method
public class User {

    @Id // Marks 'id' as the primary key of the entity
    @GeneratedValue(strategy = GenerationType.UUID) // Strategy for ID generation (delegated to JPA/Hibernate)
    @Column(name = "id") // Maps the field to a column named 'id'
    private String id;           // Unique identifier for the user

    @Column(name = "username", unique = true, nullable = false) // Maps to 'username' column, must be unique and not null
    private String username;     // The user's chosen username

    @Column(name = "email", unique = true, nullable = false) // Maps to 'email' column, must be unique and not null
    private String email;        // The user's email address

    // Ponder Point: In a real application, you'd NEVER store plain passwords.
    // They would be hashed and salted. For this educational project,
    // we are focusing on core functionality and will omit password fields for simplicity
    // to avoid security complexities at this stage.

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp // Automatically sets creation timestamp (Hibernate annotation)
    private LocalDateTime createdAt;

    @Column(name = "last_modified_at", nullable = false)
    @UpdateTimestamp // Automatically updates modification timestamp (Hibernate annotation)
    private LocalDateTime lastModifiedAt;

    /**
     * Custom constructor to create a new User instance with initial data.
     * Lombok's @NoArgsConstructor is for JPA, but we define this for application logic.
     *
     * @param username The username of the user.
     * @param email The email address of the user.
     */
    public User(String username, String email) {
        // Basic validation: ensure username and email are not null or empty
        if (username == null || username.trim().isEmpty()) {
            throw new IllegalArgumentException("Username cannot be empty.");
        }
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("Email cannot be empty.");
        }
        this.username = username;
        this.email = email;
        // createdAt and lastModifiedAt will be handled by @CreationTimestamp/@UpdateTimestamp automatically
    }

    // No need for explicit getters/setters/equals/hashCode/toString as Lombok handles them.
    // The previous explicit methods are removed here to rely on Lombok's generation.
    // Example: public String getId() { return id; } is replaced by @Getter on the class.
}
